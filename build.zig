const std = @import("std");

const FileModule = struct {
    name: []const u8,
    module: *std.Build.Module,
};

const ModuleGroup = struct {
    name: []const u8,
    group: *std.Build.Module,
    files: []const FileModule,
};

const TestGroup = struct {
    name: []const u8,
    steps: []const *std.Build.Step,
};

fn addModuleGroup(
    b: *std.Build,
    name: []const u8,
    dir_path: []const u8,
    target: std.Build.ResolvedTarget,
    optimize: std.builtin.OptimizeMode,
) ModuleGroup {
    var dir = std.fs.cwd().openDir(dir_path, .{ .iterate = true }) catch |err| {
        std.debug.panic("failed to open {s}: {s}", .{ dir_path, @errorName(err) });
    };
    defer dir.close();

    var file_names = std.ArrayList([]const u8).init(b.allocator);

    var it = dir.iterate();
    while (it.next() catch |err| {
        std.debug.panic("failed to read {s}: {s}", .{ dir_path, @errorName(err) });
    }) |entry| {
        if (entry.kind != .file) continue;
        if (!std.mem.endsWith(u8, entry.name, ".zig")) continue;
        if (std.mem.eql(u8, dir_path, "src") and std.mem.eql(u8, entry.name, "c_abi.zig")) continue;
        file_names.append(b.dupe(entry.name)) catch @panic("OOM");
    }

    std.sort.insertion([]const u8, file_names.items, {}, struct {
        fn lessThan(_: void, a: []const u8, rhs: []const u8) bool {
            return std.mem.lessThan(u8, a, rhs);
        }
    }.lessThan);

    var file_modules = std.ArrayList(FileModule).init(b.allocator);
    for (file_names.items) |file_name| {
        const stem = file_name[0 .. file_name.len - 4];
        const full_path = b.fmt("{s}/{s}", .{ dir_path, file_name });
        const mod = b.createModule(.{
            .root_source_file = b.path(full_path),
            .target = target,
            .optimize = optimize,
        });
        file_modules.append(.{
            .name = b.dupe(stem),
            .module = mod,
        }) catch @panic("OOM");
    }

    var contents = std.ArrayList(u8).init(b.allocator);
    contents.appendSlice("// generated by build.zig; do not edit\n") catch @panic("OOM");
    for (file_modules.items) |fm| {
        contents.appendSlice("pub usingnamespace @import(\"") catch @panic("OOM");
        contents.appendSlice(fm.name) catch @panic("OOM");
        contents.appendSlice("\");\n") catch @panic("OOM");
    }

    const write_files = b.addWriteFiles();
    const gen_path = write_files.add(b.fmt("generated/{s}.zig", .{name}), contents.items);

    const group_mod = b.createModule(.{
        .root_source_file = gen_path,
        .target = target,
        .optimize = optimize,
    });

    for (file_modules.items) |fm| {
        group_mod.addImport(fm.name, fm.module);
    }
    for (file_modules.items) |fm| {
        fm.module.addImport(name, group_mod);
    }

    return .{
        .name = name,
        .group = group_mod,
        .files = file_modules.items,
    };
}

fn addGroupImports(target: *std.Build.Module, group: ModuleGroup) void {
    target.addImport(group.name, group.group);
    for (group.files) |fm| {
        if (std.mem.eql(u8, fm.name, group.name)) continue;
        target.addImport(fm.name, fm.module);
    }
}

fn addTestGroup(
    b: *std.Build,
    name: []const u8,
    dir_path: []const u8,
    target: std.Build.ResolvedTarget,
    optimize: std.builtin.OptimizeMode,
    imports: []const ModuleGroup,
) TestGroup {
    var dir = std.fs.cwd().openDir(dir_path, .{ .iterate = true }) catch |err| {
        std.debug.panic("failed to open {s}: {s}", .{ dir_path, @errorName(err) });
    };
    defer dir.close();

    var file_names = std.ArrayList([]const u8).init(b.allocator);

    var it = dir.iterate();
    while (it.next() catch |err| {
        std.debug.panic("failed to read {s}: {s}", .{ dir_path, @errorName(err) });
    }) |entry| {
        if (entry.kind != .file) continue;
        if (!std.mem.endsWith(u8, entry.name, ".zig")) continue;
        file_names.append(b.dupe(entry.name)) catch @panic("OOM");
    }

    std.sort.insertion([]const u8, file_names.items, {}, struct {
        fn lessThan(_: void, a: []const u8, rhs: []const u8) bool {
            return std.mem.lessThan(u8, a, rhs);
        }
    }.lessThan);

    var run_steps = std.ArrayList(*std.Build.Step).init(b.allocator);
    for (file_names.items) |file_name| {
        const full_path = b.fmt("{s}/{s}", .{ dir_path, file_name });
        const test_step = b.addTest(.{
            .root_source_file = b.path(full_path),
            .target = target,
            .optimize = optimize,
        });
        for (imports) |group| {
            addGroupImports(test_step.root_module, group);
        }
        const run = b.addRunArtifact(test_step);
        run_steps.append(&run.step) catch @panic("OOM");
    }

    return .{
        .name = name,
        .steps = run_steps.items,
    };
}

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const events = addModuleGroup(b, "events", "src", target, optimize);

    const c_abi = b.addStaticLibrary(.{
        .name = "scenic_events",
        .root_source_file = b.path("src/c_abi.zig"),
        .target = target,
        .optimize = optimize,
    });
    c_abi.root_module.addImport("events", events.group);
    b.installArtifact(c_abi);

    const tests = addTestGroup(
        b,
        "tests",
        "tests",
        target,
        optimize,
        &.{events},
    );

    const test_step = b.step("test", "Run all tests");
    for (tests.steps) |step| test_step.dependOn(step);
}
